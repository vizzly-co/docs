# Identity

The purpose of the identity callback is to securely identify the current user. This information will be signed with your private key on your server, and validated with the public key you upload to Vizzly.

At it's simplest, this is a sequence diagram of how Vizzly works in a multi-tenant environment.

<img style={{padding: "20px", background: "white", borderRadius: "20px"}} src="/img/vizzly-high-level-how-it-works.svg" />

The Vizzly identity config contains a signature that ensure its validity when sent to the Vizzly query engine.

The API call will be made within an async function that you define, and returns an identity config.

The typescript definition of the identity config is outlined below.

```tsx
type IdentityConfig = {
    // IDs of data sets that this user has access too, or a '*'
    // if it's all of them.
    dataSets: string[] | '*';

    /*
      This is your Vizzly organisation ID, we provide this to you.
    */
    organisationId: string;

    /*
      A unique string which references the current user. For example
      a unique user ID, which is under 255 characters in length.
    */
    userReference: string;

    /*
      This is the ID of the dashboard you want the user to be shown
      when they first land on your page.
    */
    dashboardId: string;

    // ISO 8601 format.
    expires: string;

    /*
      Is the user a standard user (your customer), or are they an admin editor 
      who can edit the default dashboard & theme?
    */
    userType: 'standard' | 'editor';

    /*
      A signature that ensures all other attributes
      haven't been tampered with, and originates
      from your servers and hasn't been spoofed.
    */
    integritySignature: string;

    secureFilters: {
      [dataSetId: string]: {
        // Corresponds to the `publicField` set in the data set config.
        field: string;

        // The operation of the filter
        op: ">"
            | "<"
            | "="
            | ">="
            | "<="
            | "is_one_of"
            | "is_not_one_of"
            | "starts_with"
            | "ends_with"
            | "contains_substring"
            | "does_not_contain_substring";

        // The value to compare the field too.
        value: any;
      }[];
    };
  };
```

#### Generating test identity configs

A test identity config can be generated using our CLI tool. To do this you will need to collect your organisation ID and template dashboard ID
from [the live dashboards page](https://app.vizzly.co/dashboards) on the Vizzly website after signing in.

<img src="/img/live-dashboards-screenshot.png" />

You will then be able to run the command which __MUST__ only be used in development environments;

```shell
vizzly generate-identity-signature \
  -o org_<<rest of organisation ID>> \
  -d dsh_<<rest of dashboard ID>> \
  -u "user 123456" \
  -t editor \
  --private-key vizzly-private.pem
```
That will generate an identity signature that you can use for testing. This __MUST__ only be used in test environments, as it grants full read access to all the data 
in the database.

<details>
  <summary>Example test identity config</summary>

```json
{
  "dataSets": "*",
  "userType": "editor",
  "organisationId": "org_9817c013a.....",
  "dashboardId": "dsh_c630d48....",
  "secureFilters": {},
  "userReference": "user 123456",
  "integritySignature": "..."
  "expires": "2022-11-23T02:39:14.457Z"
}
```

</details>

### Finding parameters
To find your `organisationId` and `initialDashboard` values of your live dashboards, see the [parameters](/parameters) doc.

### Controlling data set access
If you're running the Vizzly query engine, the `dataSets` value of the identity config is where you can control what data sets your
users have access too. For example, say you have 3 data sets defined in the configuration file of your Vizzly query engine, which have IDs
`das_1`, `das_2` and `das_3`, then you could return an identity config which only specifies `das_1` and `das_2` in the `dataSets` parameter, and
prevent the user from having access to the third data set.

### Multi-tenancy with secure filters
To secure access to your data sets, you must provide a list of secure filters for each data set that is available to the user. For example, say you have
a data set with an ID of `das_1`, and you want to only show users there own data from this data set, you might specify a `secureFilters` value of:

```ts
{
  secureFilters: {
    "das_1": [{
      field: "User ID",
      op: "=",
      value: 1
    }]
  }
  // ... rest of identity config
}
```

These secure filters will be signed and sent to the Vizzly query engine by the Vizzly react embed, where they will be validated using your organisation's public key and ensure that each user only ever has access to their own data.

#### Reduce the impact of a compromised private key
If your private key becomes compromised, then one way to reduce the impact of this is to also [provide secure filters on your data sets defined in the config of your Vizzly query engine.](/query-engines/self-hosted-query-engine#optional-secure-filter-guards)

### Integrity signature
For help with signing the identity config and generating the `integritySignature` value, please see the [security docs](/security) for generating the private and public keys, as well as [this nextJs example identity callback](https://github.com/vizzly-co/library-examples/blob/90026e292e021172608a7262cbf40a4f737bac7e/examples/next-js/pages/api/identity.js#L30-L58).