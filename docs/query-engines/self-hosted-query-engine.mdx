---
sidebar_position: 1
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Self-hosted

Run a docker image in your cloud to run queries against your database and power the dashboards your users see.

The fastest way to get started with the self-hosted docker image, is to use our Vizzly CLI, which you can install by running the following command;

```shell
npm i @vizzly/cli -g
```

To see all available commands, run `vizzly -h`.

#### Creating a key-pair
To create a private and public certificate key-pair to use with Vizzly, you can run the following command
```shell
vizzly create-key-pair
```

#### Creating a Vizzly config template
After creating your key-pair, you can run the following command to create a template of the Vizzly config:
```shell
vizzly init
```

### Config file

The query engine requires some configuration to allow it to connect to your database, and to define virtual tables which are exposed to your users from which they can build their own dashboards.

The following are two examples of a config file, for Postgres and BigQuery connections.

<Tabs groupId="integration-type">
<TabItem value="postgres" label="Postgres">

```json
{
  "connection": {
    "client": "postgres",
    "connection": {
      "password": "customer",
      "database": "my_database",
      "user": "customer",
      "host": "localhost",
      "port": 6400
    }
  },
  "dataSets": [
    {
      "id": "das_e400b5180d9f419db9418510383cfb0e",
      "name": "US Sales",
      "fields": [
        {
          "name": "order_id",
          "dataType": "number",
          "id": "Order ID",
          "publicName": "Order ID",
          "table": "us_sales"
        },
        {
          "name": "order_date",
          "dataType": "date_time",
          "id": "Order Date",
          "publicName": "Order Date",
          "table": "us_sales"
        },
        {
          "name": "status",
          "dataType": "string",
          "publicName": "Status",
          "table": "us_sales_smlr_no_pii"
        },
        // ...
      ],
      "joins": []
    }
  ],
  "publicKeyCertificates": [
    "-----BEGIN PUBLIC KEY-----\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAERbmqmGHbjlNMXjHZMJsoFsDnQDT7\nk4aV5wBdlXIKe0GH+FWSwawtc8XAMURwSA7iAY2QzmzJ4RQ6ZKp1UVkpLA==\n-----END PUBLIC KEY-----"
  ]
}
```
</TabItem>
<TabItem value="bigquery" label="BigQuery">

```json
{
  "connection": {
    "client": "bigquery",
    "connection": {
      "projectId": "vizzly",
      "location": "europe-west2",
      "keyFilename":
        "/etc/vizzly-big-query-service-account.json"
    }
  },
  "dataSets": [
    {
      "id": "das_e400b5180d9f419db9418510383cfb0e",
      "name": "US Sales",
      "googleProjectId": "vizzly",
      "googleDataSetName": "us_sales",
      "fields": [
        {
          "name": "order_id",
          "dataType": "number",
          "publicName": "Order ID",
          "table": "us_sales_smlr_no_pii"
        },
        {
          "name": "order_date",
          "dataType": "date_time",
          "publicName": "Order Date",
          "table": "us_sales_smlr_no_pii"
        },
        {
          "name": "status",
          "dataType": "string",
          "publicName": "Status",
          "table": "us_sales_smlr_no_pii"
        },
        // ...
      ],
      "joins": []
    }
  ],
  "publicKeyCertificates": [
    "-----BEGIN PUBLIC KEY-----\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAERbmqmGHbjlNMXjHZMJsoFsDnQDT7\nk4aV5wBdlXIKe0GH+FWSwawtc8XAMURwSA7iAY2QzmzJ4RQ6ZKp1UVkpLA==\n-----END PUBLIC KEY-----"
  ]
}
```
</TabItem>
</Tabs>

#### File location
The Vizzly config file will need to be mounted into the Vizzly docker image, located at `/etc/vizzly/vizzly.config.json`.

#### Connection credentials
The Vizzly docker image will need read-only access to your database. These credentials are specified in the Vizzly config file, and therefore the entire config file should be treated as a secret.

The typescript definition of the credentials is as follows:

<Tabs groupId="integration-type">
<TabItem value="postgres" label="Postgres">

```ts
{
  client: "postgres";
  connection: {
    password: string;
    database: string;
    user: string;
    host: string;
    port: number;
  }
}
```
</TabItem>
<TabItem value="bigquery" label="BigQuery">

```ts
{
  client: "bigquery";
  connection: {
    projectId: string;
    location: string;
    keyFilename: string;
  }
}
```
</TabItem>
</Tabs>

#### Data sets
You'll need to define the available data sets for your users. You'll be able to define which data sets the user has access to in the [identity callback](/callbacks/identity).

The typescript definition of a data set is as follows:

<Tabs>
<TabItem value="postgres" label="Postgres">

```ts
{
  /*
    ID of the data set that remains constant.
  */
  id: string;

  /*
    A public name that describes this data set to your users.
  */
  name: string;

  /*
    Fields that define the flat schema of the data set.
  */
  fields: {
    /*
      A unique reference to this field, and should remain constant.
    */
    id: string;

    /*
      The name of the field. For example, this would be the column
      name if you're running a postgres database.
    */
    name: string;

    /*
      What type of data does this field contain?
    */
    dataType: 'number' | 'boolean' | 'string' | 'date_time';

    /*
      The name of this field that your users will see.
    */
    publicName: string;

    /*
      The name of the table in the database
    */
    table: string;
  }[];

  /*
    If you're using a SQL database, then you might need to join tables
    together to define your data set.
  */
  joins: {
      type:
        | "rightJoin"
        | "leftJoin"
        | "innerJoin"
        | "outerJoin"
        | "leftOuterJoin"
        | "rightOuterJoin";
      left: {
        field: string;
        table: string;
      };
      right: {
        field: string;
        table: string;
      };
    }[];
}
```
</TabItem>
<TabItem value="bigquery" label="BigQuery">

```ts
{
  /*
    ID of the data set that remains constant.
  */
  id: string;

  /*
    A public name that describes this data set to your users.
  */
  name: string;

  /*
    Your google project ID.
  */
  googleProjectId: string;

  /*
    Your big query data set name. (Without the project prefix.)
  */
  googleDataSetName: string;

  /*
    Fields that define the flat schema of the data set.
  */
  fields: {
    /*
      A unique reference to this field, and should remain constant.
    */
    id: string;

    /*
      The name of the field. For example, this would be the column
      name if you're running a postgres database.
    */
    name: string;

    /*
      What type of data does this field contain?
    */
    dataType: 'number' | 'boolean' | 'string' | 'date_time';

    /*
      The name of this field that your users will see.
    */
    publicName: string;

    /*
      The name of the table in the database
    */
    table: string;
  }[];

  /*
    If you're using a SQL database, then you might need to join tables
    together to define your data set.
  */
  joins: {
      type:
        | "rightJoin"
        | "leftJoin"
        | "innerJoin"
        | "outerJoin"
        | "leftOuterJoin"
        | "rightOuterJoin";
      left: {
        field: string;
        table: string;
      };
      right: {
        field: string;
        table: string;
      };
    }[];
}
```
</TabItem>
</Tabs>

#### Joins

In the Vizzly config file, it is possible to join fields that reside across multiple tables. Below is an example of how
you would join two tables on a foreign key `city_id`.

```json

{
  "connection": {
    // ...
  },
  "dataSets": [
    {
      "id": "weather-by-city",
      "name": "Weather by city",
      "fields": [
        {
          "id": "field_1",
          "publicName": "City ID",
          "name": "id",
          "table": "cities",
          "dataType": "number"
        },
        {
          "id": "field_2",
          "publicName": "City",
          "name": "name",
          "table": "cities",
          "dataType": "number"
        },
        {
          "id": "field_3",
          "publicName": "Weather record ID",
          "name": "id",
          "table": "weather",
          "dataType": "number"
        },
        {
          "id": "field_4",
          "publicName": "City ID",
          "name": "city_id",
          "table": "weather",
          "dataType": "number"
        },
        {
          "id": "field_5",
          "publicName": "High temperature",
          "name": "high_temperature",
          "table": "weather",
          "dataType": "number"
        }
      ],
      "joins": [
        {
          "type": "leftJoin",
          "left": {
            "field": "id",
            "table": "cities"
          },
          "right": {
            "field": "city_id",
            "table": "weather"
          }
        }
      ],
      "secureFilterGuards": []
    },
    // ...
  ],
  "publicKeyCertificates": [
    // ...
  ]
}
```

#### Optional secure filter guards
Secure filters are defined in the [identity config](/callbacks/identity). However if you want to reduce the impact of your private key becoming compromised, you can also
define secure filter guards for each of the data sets. The purpose of filter guards is not to prevent unauthorised access, only to limit the amount of data an attacker has
access too if they manage to steal your private key used for Vizzly.

The typescript definition of a secure filter guard is as follows:

```ts
type Operator =
    | ">"
    | "<"
    | "="
    | ">="
    | "<="
    | "is_one_of"
    | "is_not_one_of"
    | "starts_with"
    | "ends_with"      
    | "contains_substring"
    | "does_not_contain_substring";

{
  fieldId: string; // The `id` of the field
  op: Operator;
};
```

### Cloud deployment

<Tabs>
<TabItem value="aws" label="Amazon Web Services (AWS)">

To pull down configuration from an S3 bucket, specify the `VIZZLY_CONFIG_S3_BUCKET_NAME` and `VIZZLY_CONFIG_S3_BUCKET_REGION` environment variables.

For example, `VIZZLY_CONFIG_S3_BUCKET_NAME=secure-vizzly-config` and `VIZZLY_CONFIG_S3_BUCKET_REGION=eu-west-2`.

This will download all the files in the bucket `secure-vizzly-config` in the region `VIZZLY_CONFIG_S3_BUCKET_REGION`, and save them to `/etc/vizzly`, so
naming the config file `vizzly.config.json` will download the config to the correct place.

As this config file will contain read-only database credentials, be sure to store this securely in S3 with the correct permissions.

</TabItem>
<TabItem value="gcp" label="Google Cloud Platform (GCP)">

Please contact us for support setting up on Google Cloud Platform.
</TabItem>
</Tabs>

### Environment variables

#### `VIZZLY_QUERY_ENGINE_HOST`
The protocol and host domain of the query engine. This excludes the base path which can be configured using the `VIZZLY_BASE_PATH` variable.
For example `https://query.example.co` would be a valid query engine host value.

This environment variable is required.

#### `VIZZLY_BASE_PATH`
This changes the base path of the Vizzly query engine. For example you might have a routing layer that matches requests for `/vizzly-query-engine/*`, and forwards them too the 
query engine. In which case, you'd set this value too `/vizzly-query-engine` so the requests match the path matchers in the query engine.

This environment variable is not required, and defaults too `''`.

#### `VIZZLY_RESPONSE_LIMIT`
This sets the maximum size of query result responses. We only recommended changing this value if you're lowering it.

This environment variable is not required, and defaults to `5mb`.

#### `VIZZLY_CONFIG_FILE`
Changes the path at which the config file resides inside the running container.

This environment variable is not required, and defaults to `/etc/vizzly/vizzly.config.json`.

### Performance and resiliency

#### Workload
The docker image we provide does not do computationally heavy lifting. The noteworthy operations include validating JWTs and transforming Vizzly queries into the language your underlying database requires.

#### Hardware considerations
The recommended hardware requirements will depend on a number of different factors, including:
- The number of concurrent users you expect to be viewing the dashboard.
- How many charts a typical user has on their dashboard.
- How many additional data controls exist on each chart.

To increase performance, consider scaling horizontally by adding more containers running the Vizzly docker image, or vertically by provisioning larger compute resource.

#### Resiliency
The query engine in the docker image is stateless and so it can be easily scaled horizontally to reduce performance or resiliency concerns and easily auto-scaled on all major cloud providers if your traffic pattern is spiky.

### Limitations

#### Large numbers
Currently, the self-hosted docker image supports a precision of up to `9007199254740991`. The accuracy of operations performed on numbers greater than this number may be incorrect.
