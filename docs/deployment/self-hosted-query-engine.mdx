---
sidebar_position: 2
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Self-hosted

To make it easy to get started, Vizzly provides a docker image that securely queries your database to power the dashboards your users see.

[The docker image can be found here](https://github.com/vizzly-co/query-engine/pkgs/container/query-engine)

### Config file

The query engine requires some configuration to allow it to connect to your database, and to learn how to map queries to your database.

The following are two examples of a config file, for Postgres and BigQuery connections.


<Tabs groupId="integration-type">
<TabItem value="postgres" label="Postgres">

```json
{
  "connection": {
    "client": "postgres",
    "connection": {
      "password": "customer",
      "database": "my_database",
      "user": "customer",
      "host": "localhost",
      "port": 6400
    }
  },
  "dataSets": [
    {
      "id": "das_e400b5180d9f419db9418510383cfb0e",
      "name": "US Sales",
      "fields": [
        {
          "name": "order_id",
          "dataType": "number",
          "id": "Order ID",
          "publicName": "Order ID",
          "table": "us_sales"
        },
        {
          "name": "order_date",
          "dataType": "date_time",
          "id": "Order Date",
          "publicName": "Order Date",
          "table": "us_sales"
        },
        {
          "name": "status",
          "dataType": "string",
          "publicName": "Status",
          "table": "us_sales_smlr_no_pii"
        },
        // ...
      ],
      "joins": []
    }
  ],
  "publicKeyCertificates": [
    "-----BEGIN PUBLIC KEY-----\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAERbmqmGHbjlNMXjHZMJsoFsDnQDT7\nk4aV5wBdlXIKe0GH+FWSwawtc8XAMURwSA7iAY2QzmzJ4RQ6ZKp1UVkpLA==\n-----END PUBLIC KEY-----"
  ]
}
```
</TabItem>
<TabItem value="bigquery" label="BigQuery">

```json
{
  "connection": {
    "client": "bigquery",
    "connection": {
      "projectId": "vizzly",
      "location": "europe-west2",
      "keyFilename":
        "/etc/vizzly-big-query-service-account.json"
    }
  },
  "dataSets": [
    {
      "id": "das_e400b5180d9f419db9418510383cfb0e",
      "name": "US Sales",
      "googleProjectId": "vizzly",
      "googleDataSetName": "us_sales",
      "fields": [
        {
          "name": "order_id",
          "dataType": "number",
          "publicName": "Order ID",
          "table": "us_sales_smlr_no_pii"
        },
        {
          "name": "order_date",
          "dataType": "date_time",
          "publicName": "Order Date",
          "table": "us_sales_smlr_no_pii"
        },
        {
          "name": "status",
          "dataType": "string",
          "publicName": "Status",
          "table": "us_sales_smlr_no_pii"
        },
        // ...
      ],
      "joins": []
    }
  ],
  "publicKeyCertificates": [
    "-----BEGIN PUBLIC KEY-----\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAERbmqmGHbjlNMXjHZMJsoFsDnQDT7\nk4aV5wBdlXIKe0GH+FWSwawtc8XAMURwSA7iAY2QzmzJ4RQ6ZKp1UVkpLA==\n-----END PUBLIC KEY-----"
  ]
}
```
</TabItem>
</Tabs>

#### File location
The Vizzly config file will need to be mounted into the Vizzly docker image, located at `/etc/config.vizzly.json`.

#### Security
The config file should be treated as a secret, as it will contain read-only credentials to your database.

#### Connection credentials
The Vizzly docker image will need read-only access to your database. These credentials are specified in the Vizzly config file, and therefore the entire config file should be treated as a secret.

The typescript definition of the credentials is as follows:

<Tabs groupId="integration-type">
<TabItem value="postgres" label="Postgres">

```ts
{
  client: "postgres";
  connection: {
    password: string;
    database: string;
    user: string;
    host: string;
    port: number;
  }
}
```
</TabItem>
<TabItem value="bigquery" label="BigQuery">

```ts
{
  client: "bigquery";
  connection: {
    projectId: string;
    location: string;
    keyFilename: string;
  }
}
```
</TabItem>
</Tabs>

#### Data sets
You'll need to define the available data sets for your users. You'll be able to define which data sets the user has access to in the [identity callback](/callbacks/identity).

The typescript definition of a data set is as follows:

<Tabs>
<TabItem value="bigquery" label="BigQuery">

```ts
{
  /*
    ID of the data set that remains constant.

    For data sets used in default dashboards, this ID will be prefixed
    with `das_` and will be provided for you in the studio. For additional data
    sets you will define this unique ID yourself.
  */
  id: string;

  /*
    A public name that describes this data set to your users.
  */
  name: string;

  /*
    Fields that define the flat schema of the data set.
  */
  fields: {
    /*
      A unique reference to this field, and should remain constant.
    */
    id: string;

    /*
      The name of the field. For example, this would be the column
      name if you're running a postgres database.
    */
    name: string;

    /*
      What type of data does this field contain?
    */
    dataType: 'number' | 'boolean' | 'string' | 'date_time';

    /*
      The name of this field that your users will see.
    */
    publicName: string;

    /*
      The name of the table in the database
    */
    table: string;
  }[];

  /*
    If you're using a SQL database, then you might need to join tables
    together to define your data set.
  */
  joins: {
      type:
        | "rightJoin"
        | "leftJoin"
        | "innerJoin"
        | "outerJoin"
        | "leftOuterJoin"
        | "rightOuterJoin";
      left: {
        field: string;
        table: string;
      };
      right: {
        field: string;
        table: string;
      };
    }[];
}
```
</TabItem>
<TabItem value="postgres" label="Postgres">

```ts
{
  /*
    ID of the data set that remains constant.

    For data sets used in default dashboards, this ID will be prefixed
    with `das_` and will be provided for you in the studio. For additional data
    sets you will define this unique ID yourself.
  */
  id: string;

  /*
    A public name that describes this data set to your users.
  */
  name: string;

  /*
    Your google project ID.
  */
  googleProjectId: string;

  /*
    Your big query data set name. (Without the project prefix.)
  */
  googleDataSetName: string;

  /*
    Fields that define the flat schema of the data set.
  */
  fields: {
    /*
      A unique reference to this field, and should remain constant.
    */
    id: string;

    /*
      The name of the field. For example, this would be the column
      name if you're running a postgres database.
    */
    name: string;

    /*
      What type of data does this field contain?
    */
    dataType: 'number' | 'boolean' | 'string' | 'date_time';

    /*
      The name of this field that your users will see.
    */
    publicName: string;

    /*
      The name of the table in the database
    */
    table: string;
  }[];

  /*
    If you're using a SQL database, then you might need to join tables
    together to define your data set.
  */
  joins: {
      type:
        | "rightJoin"
        | "leftJoin"
        | "innerJoin"
        | "outerJoin"
        | "leftOuterJoin"
        | "rightOuterJoin";
      left: {
        field: string;
        table: string;
      };
      right: {
        field: string;
        table: string;
      };
    }[];
}
```
</TabItem>
</Tabs>

#### Optional secure filters
Secure filters are typically defined in the [identity callback](/callbacks/identity). However if you want to reduce the impact of your private key becoming compromised, you can also define the secure filters for each of the data sets here. The trade-off here is between flexibility of dynamic secure filters and an additional level of security. This will not completely prevent unauthorised access, however it might reduce the amount of data an attacker has access too even if they manage to steal your private key.

The typescript definition of a secure filter is as follows:

```ts
type Operator =
    | ">"
    | "<"
    | "="
    | ">="
    | "<="
    | "is_one_of"
    | "is_not_one_of"
    | "starts_with"
    | "ends_with"      
    | "contains_substring"
    | "does_not_contain_substring";

{
  field: string; // '<<table>>.<<field name>>', e.g users.id
  op: Operator;
};
```

### Joins

In the Vizzly config file, it is possible to join fields that reside across multiple tables. Below is an example of how
you would join two tables. One which has city information, and another table which has temperature information for each city.

```json

{
  "connection": {
    // ...
  },
  "dataSets": [
    {
      "id": "weather-by-city",
      "name": "Weather by city",
      "fields": [
        {
          "id": "field_1",
          "publicName": "City ID",
          "name": "id",
          "table": "cities",
          "dataType": "number"
        },
        {
          "id": "field_2",
          "publicName": "City",
          "name": "name",
          "table": "cities",
          "dataType": "number"
        },
        {
          "id": "field_3",
          "publicName": "Weather record ID",
          "name": "id",
          "table": "weather",
          "dataType": "number"
        },
        {
          "id": "field_4",
          "publicName": "City ID",
          "name": "city_id",
          "table": "weather",
          "dataType": "number"
        },
        {
          "id": "field_5",
          "publicName": "High temperature",
          "name": "high_temperature",
          "table": "weather",
          "dataType": "number"
        }
      ],
      "joins": [
        {
          "type": "leftJoin",
          "left": {
            "field": "id",
            "table": "cities"
          },
          "right": {
            "field": "city_id",
            "table": "weather"
          }
        }
      ],
      "secureFilters": []
    },
    // ...
  ],
  "publicKeyCertificates": [
    // ...
  ]
}
```

### Performance and resiliency

#### Workload
The docker image we provide does not do computationally heavy lifting. The noteworthy operations include validating JWTs and transforming Vizzly queries into the language your underlying database requires.

#### Hardware considerations
The recommended hardware requirements will depend on a number of different factors, including:
- The number of concurrent users you expect to be viewing the dashboard.
- How many charts a typical user has on their dashboard.
- How many additional data controls exist on each chart.

To increase performance, consider scaling horizontally by adding more containers running the Vizzly docker image, or vertically by provisioning larger compute resource.

#### Resiliency
The query engine in the docker image is stateless and so it can be easily scaled horizontally to reduce performance or resiliency concerns and also auto-scaled if your traffic pattern is spiky.

### Limitations

#### Large numbers
Currently, the self-hosted docker image supports a precision of up to `9007199254740991`. The accuracy of operations performed on numbers greater than this number may be incorrect.
