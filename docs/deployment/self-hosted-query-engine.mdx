---
sidebar_position: 2
---

# Self-hosted query engine

To make it easy to get started, Vizzly provides a docker image that when ran, will provide an endpoint that transforms Vizzly queries into Vizzly results. You will provide it read-only credentials to your underlying database, and it will run queries safely against your database. [Learn more about Vizzly security here](/security).

### Config file

The query engine requires some configuration to allow it to connect to your database, and know how to map queries to how your data is structured. For example, if you're running a SQL database, the docker image might need to know how to join tables together to produce the dataset that's available for querying.

#### Connection credentials
The Vizzly docker image will need read-only access to your database. These credentials are specified in the Vizzly config file, and therefore the entire config file should be treated as a secret.

The typescript definition of the credentials is as follows:

```ts
{
  client: "postgres";
  connection: {
    password: string;
    database: string;
    user: string;
    host: string;
    port: number;
  }
}
```

#### Data sets
You'll need to define the available data sets for your users. You'll be able to define which data sets the user has access to in the [identity callback](/callbacks/identity).

The typescript definition of a data set is as follows:

```ts
{
  /*
    For default data sets that are available to all your users,
    this will be provided to you from the Vizzly platform. For dynamic
    data sets, this will be an ID generated by you. It's important that
    this ID remains constant, as it's used as a reference to this data set schema.
  */
  id: string;

  /*
    A public name that describes this data set to your users.
  */
  name: string;
  fields: {
    /*
      The name of the field. For example, this would be the column
      name if you're running a postgres database.
    */
    name: string;

    /*
      What type of data does this field contain?
    */
    dataType: 'number' | 'boolean' | 'string' | 'date_time';

    /*
      The name of this field that your users will see.
    */
    publicName: string;

    /*
      The name of the collection that the field resides. For example
      this will be the name of a table in your SQL database.
    */
    collection: string;
  }[];

  /*
    If you're using a SQL database, then you might need to join tables
    together that defines your data set.
  */
  joins: {
      type:
        | "rightJoin"
        | "leftJoin"
        | "innerJoin"
        | "outerJoin"
        | "leftOuterJoin"
        | "rightOuterJoin";
      left: {
        fieldName: string;
        fieldCollection: string;
      };
      right: {
        fieldName: string;
        fieldCollection: string;
      };
    }[];
}
```

#### Optional secure filters
Secure filters are typically defined in the [identity callback](/callbacks/identity). However if you want to protect against the worst case scenario of your private key becoming compromised, you can also define the secure filters for each of the data sets here. The trade-off here is between flexibility of dynamic secure filters and an additional level of security.

The typescript definition of a secure filter is as follows:

```ts
type Operator =
    | ">"
    | "<"
    | "="
    | ">="
    | "<="
    | "is_one_of"
    | "is_not_one_of"
    | "starts_with"
    | "ends_with"      
    | "contains_substring"
    | "does_not_contain_substring";

{
  field: string; // '<<collection>>.<<field name>>', e.g users.id
  op: Operator;
};
```


#### Full example
```json
{
  "connection": {
    "client": "postgres",
    "connection": {
      "password": "customer",
      "database": "my_database",
      "user": "customer",
      "host": "host.docker.internal",
      "port": 6400
    }
  },
  "dataSets": [
    {
      "id": "das_e400b5180d9f419db9418510383cfb0e",
      "name": "US Sales",
      "fields": [
        {
          "name": "order_id",
          "dataType": "number",
          "publicName": "Order ID",
          "collection": "us_sales"
        },
        {
          "name": "order_date",
          "dataType": "date_time",
          "publicName": "Order Date",
          "collection": "us_sales"
        },
        {
          "name": "status",
          "dataType": "string",
          "publicName": "Status",
          "collection": "us_sales"
        }
      ],
      "joins": []
    }
  ],
  "publicKeyCertificates": [
    "-----BEGIN PUBLIC KEY-----\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAERbmqmGHbjlNMXjHZMJsoFsDnQDT7\nk4aV5wBdlXIKe0GH+FWSwawtc8XAMURwSA7iAY2QzmzJ4RQ6ZKp1UVkpLA==\n-----END PUBLIC KEY-----"
  ]
}
```

### Limitations

#### Large numbers
Currently, the self-hosted docker image supports a precision of up to `9007199254740991`. The accuracy of operations performed on numbers greater than this number may be incorrect.
