---
sidebar_position: 2
---

# Self-hosted

To make it easy to get started, Vizzly provides a docker image that securely queries your database to power the dashboards your users see.

### Config file

The query engine requires some configuration to allow it to connect to your database, and know how to map queries to how your data is structured. For example, if you're running a SQL database, the docker image might need to know how to join tables together to produce the dataset that's available for querying.

#### File location
The Vizzly config file will need to be mounted into the Vizzly docker image, located at `/etc/config.vizzly.json`.

#### Security
The config file should be treated as a secret, as it will contain read-only credentials to your database.

#### Connection credentials
The Vizzly docker image will need read-only access to your database. These credentials are specified in the Vizzly config file, and therefore the entire config file should be treated as a secret.

The typescript definition of the credentials is as follows:

```ts
{
  client: "postgres";
  connection: {
    password: string;
    database: string;
    user: string;
    host: string;
    port: number;
  }
}
```

#### Data sets
You'll need to define the available data sets for your users. You'll be able to define which data sets the user has access to in the [identity callback](/callbacks/identity).

The typescript definition of a data set is as follows:

```ts
{
  /*
    For default data sets that are available to all your users,
    this will be provided to you from the Vizzly platform. For dynamic
    data sets, this will be an ID generated by you. It's important that
    this ID remains constant, as it's used as a reference to this data set schema.
  */
  id: string;

  /*
    A public name that describes this data set to your users.
  */
  name: string;
  fields: {
    /*
      The name of the field. For example, this would be the column
      name if you're running a postgres database.
    */
    name: string;

    /*
      What type of data does this field contain?
    */
    dataType: 'number' | 'boolean' | 'string' | 'date_time';

    /*
      The name of this field that your users will see.
    */
    publicName: string;

    /*
      The name of the collection that the field resides. For example
      this will be the name of a table in your SQL database.
    */
    collection: string;
  }[];

  /*
    If you're using a SQL database, then you might need to join tables
    together to define your data set.
  */
  joins: {
      type:
        | "rightJoin"
        | "leftJoin"
        | "innerJoin"
        | "outerJoin"
        | "leftOuterJoin"
        | "rightOuterJoin";
      left: {
        fieldName: string;
        fieldCollection: string;
      };
      right: {
        fieldName: string;
        fieldCollection: string;
      };
    }[];
}
```

#### Optional secure filters
Secure filters are typically defined in the [identity callback](/callbacks/identity). However if you want to reduce the impact of your private key becoming compromised, you can also define the secure filters for each of the data sets here. The trade-off here is between flexibility of dynamic secure filters and an additional level of security. This will not completely prevent unauthorised access, however it might reduce the amount of data an attacker has access too even if they manage to steal your private key.

The typescript definition of a secure filter is as follows:

```ts
type Operator =
    | ">"
    | "<"
    | "="
    | ">="
    | "<="
    | "is_one_of"
    | "is_not_one_of"
    | "starts_with"
    | "ends_with"      
    | "contains_substring"
    | "does_not_contain_substring";

{
  field: string; // '<<collection>>.<<field name>>', e.g users.id
  op: Operator;
};
```


#### Full example
```json
{
  "connection": {
    "client": "postgres",
    "connection": {
      "password": "customer",
      "database": "my_database",
      "user": "customer",
      "host": "host.docker.internal",
      "port": 6400
    }
  },
  "dataSets": [
    {
      "id": "das_e400b5180d9f419db9418510383cfb0e",
      "name": "US Sales",
      "fields": [
        {
          "name": "order_id",
          "dataType": "number",
          "publicName": "Order ID",
          "collection": "us_sales"
        },
        {
          "name": "order_date",
          "dataType": "date_time",
          "publicName": "Order Date",
          "collection": "us_sales"
        },
        {
          "name": "status",
          "dataType": "string",
          "publicName": "Status",
          "collection": "us_sales"
        }
      ],
      "joins": []
    }
  ],
  "publicKeyCertificates": [
    "-----BEGIN PUBLIC KEY-----\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAERbmqmGHbjlNMXjHZMJsoFsDnQDT7\nk4aV5wBdlXIKe0GH+FWSwawtc8XAMURwSA7iAY2QzmzJ4RQ6ZKp1UVkpLA==\n-----END PUBLIC KEY-----"
  ]
}
```

### Performance and resiliency

#### Workload
The docker image we provide does not do computationally heavy lifting. The noteworthy operations include validating JWTs and transforming Vizzly queries into the language your underlying database requires.

#### Hardware considerations
The recommended hardware requirements will depend on a number of different factors, including:
- The number of concurrent users you expect to be viewing the dashboard.
- How many charts a typical user has on their dashboard.
- How many additional data controls exist on each chart.

To increase performance, consider scaling horizontally by adding more containers running the Vizzly docker image, or vertically by provisioning larger compute resource.

#### Resiliency
The query engine in the docker image is stateless and so it can be easily scaled horizontally to reduce performance or resiliency concerns and also auto-scaled if your traffic pattern is spiky.

### Limitations

#### Large numbers
Currently, the self-hosted docker image supports a precision of up to `9007199254740991`. The accuracy of operations performed on numbers greater than this number may be incorrect.
