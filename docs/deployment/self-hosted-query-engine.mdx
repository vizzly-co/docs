---
sidebar_position: 2
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Self-hosted

To make it easy to get started, Vizzly provides a docker image that securely queries your database to power the dashboards your users see.

[The docker image can be found here](https://github.com/vizzly-co/query-engine/pkgs/container/query-engine)

### Config file

The query engine requires some configuration to allow it to connect to your database, and to learn how to map queries to your database.

The following are two examples of a config file, for Postgres and BigQuery connections.


<Tabs groupId="integration-type">
<TabItem value="postgres" label="Postgres">

```json
{
  "connection": {
    "client": "postgres",
    "connection": {
      "password": "customer",
      "database": "my_database",
      "user": "customer",
      "host": "localhost",
      "port": 6400
    }
  },
  "dataSets": [
    {
      "id": "das_e400b5180d9f419db9418510383cfb0e",
      "name": "US Sales",
      "fields": [
        {
          "name": "order_id",
          "dataType": "number",
          "id": "Order ID",
          "publicName": "Order ID",
          "table": "us_sales"
        },
        {
          "name": "order_date",
          "dataType": "date_time",
          "id": "Order Date",
          "publicName": "Order Date",
          "table": "us_sales"
        },
        {
          "name": "status",
          "dataType": "string",
          "publicName": "Status",
          "table": "us_sales_smlr_no_pii"
        },
        // ...
      ],
      "joins": []
    }
  ],
  "publicKeyCertificates": [
    "-----BEGIN PUBLIC KEY-----\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAERbmqmGHbjlNMXjHZMJsoFsDnQDT7\nk4aV5wBdlXIKe0GH+FWSwawtc8XAMURwSA7iAY2QzmzJ4RQ6ZKp1UVkpLA==\n-----END PUBLIC KEY-----"
  ]
}
```
</TabItem>
<TabItem value="bigquery" label="BigQuery">

```json
{
  "connection": {
    "client": "bigquery",
    "connection": {
      "projectId": "vizzly",
      "location": "europe-west2",
      "keyFilename":
        "/etc/vizzly-big-query-service-account.json"
    }
  },
  "dataSets": [
    {
      "id": "das_e400b5180d9f419db9418510383cfb0e",
      "name": "US Sales",
      "googleProjectId": "vizzly",
      "googleDataSetName": "us_sales",
      "fields": [
        {
          "name": "order_id",
          "dataType": "number",
          "publicName": "Order ID",
          "table": "us_sales_smlr_no_pii"
        },
        {
          "name": "order_date",
          "dataType": "date_time",
          "publicName": "Order Date",
          "table": "us_sales_smlr_no_pii"
        },
        {
          "name": "status",
          "dataType": "string",
          "publicName": "Status",
          "table": "us_sales_smlr_no_pii"
        },
        // ...
      ],
      "joins": []
    }
  ],
  "publicKeyCertificates": [
    "-----BEGIN PUBLIC KEY-----\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAERbmqmGHbjlNMXjHZMJsoFsDnQDT7\nk4aV5wBdlXIKe0GH+FWSwawtc8XAMURwSA7iAY2QzmzJ4RQ6ZKp1UVkpLA==\n-----END PUBLIC KEY-----"
  ]
}
```
</TabItem>
</Tabs>

#### File location
The Vizzly config file will need to be mounted into the Vizzly docker image, located at `/etc/vizzly/vizzly.config.json`.

#### AWS Deployment
To pull down configuration from an S3 bucket, specify the `VIZZLY_CONFIG_S3_BUCKET_NAME` and `VIZZLY_CONFIG_S3_BUCKET_REGION` environment variables.

For example, `VIZZLY_CONFIG_S3_BUCKET_NAME=secure-vizzly-config` and `VIZZLY_CONFIG_S3_BUCKET_REGION=eu-west-2`.

This will download all the files in the bucket `secure-vizzly-config` in the region `VIZZLY_CONFIG_S3_BUCKET_REGION`, and save them to `/etc/vizzly`, so
naming the config file `vizzly.config.json` will download the config to the correct place.

As this config file will contain read-only database credentials, be sure to store this securely in S3 with the correct permissions.

#### Security
The config file should be treated as a secret, as it will contain read-only credentials to your database.

#### Connection credentials
The Vizzly docker image will need read-only access to your database. These credentials are specified in the Vizzly config file, and therefore the entire config file should be treated as a secret.

The typescript definition of the credentials is as follows:

<Tabs groupId="integration-type">
<TabItem value="postgres" label="Postgres">

```ts
{
  client: "postgres";
  connection: {
    password: string;
    database: string;
    user: string;
    host: string;
    port: number;
  }
}
```
</TabItem>
<TabItem value="bigquery" label="BigQuery">

```ts
{
  client: "bigquery";
  connection: {
    projectId: string;
    location: string;
    keyFilename: string;
  }
}
```
</TabItem>
</Tabs>

#### Data sets
You'll need to define the available data sets for your users. You'll be able to define which data sets the user has access to in the [identity callback](/callbacks/identity).

The typescript definition of a data set is as follows:

<Tabs>
<TabItem value="bigquery" label="BigQuery">

```ts
{
  /*
    ID of the data set that remains constant.

    For data sets used in default dashboards, this ID will be prefixed
    with `das_` and will be provided for you in the studio. For additional data
    sets you will define this unique ID yourself.
  */
  id: string;

  /*
    A public name that describes this data set to your users.
  */
  name: string;

  /*
    Fields that define the flat schema of the data set.
  */
  fields: {
    /*
      A unique reference to this field, and should remain constant.
    */
    id: string;

    /*
      The name of the field. For example, this would be the column
      name if you're running a postgres database.
    */
    name: string;

    /*
      What type of data does this field contain?
    */
    dataType: 'number' | 'boolean' | 'string' | 'date_time';

    /*
      The name of this field that your users will see.
    */
    publicName: string;

    /*
      The name of the table in the database
    */
    table: string;
  }[];

  /*
    If you're using a SQL database, then you might need to join tables
    together to define your data set.
  */
  joins: {
      type:
        | "rightJoin"
        | "leftJoin"
        | "innerJoin"
        | "outerJoin"
        | "leftOuterJoin"
        | "rightOuterJoin";
      left: {
        field: string;
        table: string;
      };
      right: {
        field: string;
        table: string;
      };
    }[];
}
```
</TabItem>
<TabItem value="postgres" label="Postgres">

```ts
{
  /*
    ID of the data set that remains constant.

    For data sets used in default dashboards, this ID will be prefixed
    with `das_` and will be provided for you in the studio. For additional data
    sets you will define this unique ID yourself.
  */
  id: string;

  /*
    A public name that describes this data set to your users.
  */
  name: string;

  /*
    Your google project ID.
  */
  googleProjectId: string;

  /*
    Your big query data set name. (Without the project prefix.)
  */
  googleDataSetName: string;

  /*
    Fields that define the flat schema of the data set.
  */
  fields: {
    /*
      A unique reference to this field, and should remain constant.
    */
    id: string;

    /*
      The name of the field. For example, this would be the column
      name if you're running a postgres database.
    */
    name: string;

    /*
      What type of data does this field contain?
    */
    dataType: 'number' | 'boolean' | 'string' | 'date_time';

    /*
      The name of this field that your users will see.
    */
    publicName: string;

    /*
      The name of the table in the database
    */
    table: string;
  }[];

  /*
    If you're using a SQL database, then you might need to join tables
    together to define your data set.
  */
  joins: {
      type:
        | "rightJoin"
        | "leftJoin"
        | "innerJoin"
        | "outerJoin"
        | "leftOuterJoin"
        | "rightOuterJoin";
      left: {
        field: string;
        table: string;
      };
      right: {
        field: string;
        table: string;
      };
    }[];
}
```
</TabItem>
</Tabs>

#### Joins

In the Vizzly config file, it is possible to join fields that reside across multiple tables. Below is an example of how
you would join two tables on a foreign key `city_id`.

```json

{
  "connection": {
    // ...
  },
  "dataSets": [
    {
      "id": "weather-by-city",
      "name": "Weather by city",
      "fields": [
        {
          "id": "field_1",
          "publicName": "City ID",
          "name": "id",
          "table": "cities",
          "dataType": "number"
        },
        {
          "id": "field_2",
          "publicName": "City",
          "name": "name",
          "table": "cities",
          "dataType": "number"
        },
        {
          "id": "field_3",
          "publicName": "Weather record ID",
          "name": "id",
          "table": "weather",
          "dataType": "number"
        },
        {
          "id": "field_4",
          "publicName": "City ID",
          "name": "city_id",
          "table": "weather",
          "dataType": "number"
        },
        {
          "id": "field_5",
          "publicName": "High temperature",
          "name": "high_temperature",
          "table": "weather",
          "dataType": "number"
        }
      ],
      "joins": [
        {
          "type": "leftJoin",
          "left": {
            "field": "id",
            "table": "cities"
          },
          "right": {
            "field": "city_id",
            "table": "weather"
          }
        }
      ],
      "secureFilterGuards": []
    },
    // ...
  ],
  "publicKeyCertificates": [
    // ...
  ]
}
```

#### Optional secure filter guards
Secure filters are defined in the [identity config](/callbacks/identity). However if you want to reduce the impact of your private key becoming compromised, you can also
define secure filter guards for each of the data sets. The purpose of filter guards is not to prevent unauthorised access, only to limit the amount of data an attacker has
access too if they manage to steal your private key used for Vizzly.

The typescript definition of a secure filter guard is as follows:

```ts
type Operator =
    | ">"
    | "<"
    | "="
    | ">="
    | "<="
    | "is_one_of"
    | "is_not_one_of"
    | "starts_with"
    | "ends_with"      
    | "contains_substring"
    | "does_not_contain_substring";

{
  fieldId: string; // The `id` of the field
  op: Operator;
};
```

### Performance and resiliency

#### Workload
The docker image we provide does not do computationally heavy lifting. The noteworthy operations include validating JWTs and transforming Vizzly queries into the language your underlying database requires.

#### Hardware considerations
The recommended hardware requirements will depend on a number of different factors, including:
- The number of concurrent users you expect to be viewing the dashboard.
- How many charts a typical user has on their dashboard.
- How many additional data controls exist on each chart.

To increase performance, consider scaling horizontally by adding more containers running the Vizzly docker image, or vertically by provisioning larger compute resource.

#### Resiliency
The query engine in the docker image is stateless and so it can be easily scaled horizontally to reduce performance or resiliency concerns and also auto-scaled if your traffic pattern is spiky.

### Limitations

#### Large numbers
Currently, the self-hosted docker image supports a precision of up to `9007199254740991`. The accuracy of operations performed on numbers greater than this number may be incorrect.
