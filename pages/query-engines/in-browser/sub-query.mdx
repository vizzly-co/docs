import { Tab, Tabs } from "nextra-theme-docs";
import Link from "next/link";

# Subquery

Sometimes, multiple queries are required to transform the data in your data set, to find the answer you are looking for.

For example, you might want to calculate the percentage of your employees who are female. You will need to;

1. Count total number of staff, and count the total number of those which are female.
2. Divide the number of female staff, with the total number of employees and multiply this by 100.

You can see here that there are two stages to finding out the result, and each stage requires a query.

### In Vizzly

The current way Vizzly supports this, is to return a subquery data set from the <Link style={{textDecoration: "underline"}} href="/dashboard/callbacks/loadDataSetsCallback">loadDataSetsCallback</Link>. This is a data set which is built by referencing
a normal data set and providing a query.

<Tabs items={["Type definition", "Example"]}>
  <Tab>

```typescript
{
  id: string;
  name: string;
  subquery: {
    // https://docs.vizzly.co/concepts/query
    query: Query;
    // Virtual fields only used to run the subquery against the base data set.
    // https://docs.vizzly.co/concepts/virtualField
    virtualFields: Array<VirtualField>;
  };
  // Virtual fields only to use on the data set, after the subquery has been ran.
  // https://docs.vizzly.co/concepts/virtualField
  virtualFields?: Array<VirtualField>;
};
```

  </Tab>
  <Tab>

```typescript
// Build the subquery used to define the data set.
// This subquery defines 2 fields. The first is built from a virtual field
// which counts the number of rows where the `status` field equals `completed`.
const subquery = {
  query: {
    // ID of the data set to base the subquery off
    dataSetId: "das_123",
    measure: [
      { field: "vfie_1", aggregate: "sum" },
      { field: "status", aggregate: "count" },
    ],
    filter: [],
    order: [],
    dimension: [],
    timeDimension: null,
  },
  virtualFields: [
    {
      definition: [
        // If the `status` is "complete", then use the value `1`, otherwise `0`
        {
          if: [[{ field: "status", op: "=", value: "complete" }]],
          then: [1, "+", 0],
          else: [0, "+", 0],
        },
        "+",
        // Just add `0`, because we are using the condition to return either a `1` or a `0`
        // So that our count increments by `0` (no increment) or `1`.
        [0, "+", 0],
      ],
      field: {
        id: "vfie_1",
        publicName: "Count of status completed",
        canBeDimension: false,
        canBeMeasure: true,
        dataType: "number",
        allowedOperators: ["="],
      },
    },
  ],
};

// Define the data set which uses the subquery.
const subQueryDataSet = {
  id: "subquery_data_set_1",
  name: "Percentage complete data set",
  subquery,
  // Define virtual fields which use the results from the subquery.
  virtualFields: [
    {
      field: {
        id: "vfie_percentage_completed",
        publicName: "Percentage completed",
        canBeDimension: false,
        canBeMeasure: true,
        dataType: "number",
        allowedOperators: [],
      },

      // Note the fields referenced from the subquery result, are
      // represented as the field joined with the aggregate applied.
      // e.g `vfie_1` with the sum aggregate applied, is now `vfie_1_sum`.
      definition: [
        [
          { field: "vfie_1_sum", aggregate: "none" },
          "/",
          { field: "status_count", aggregate: "none" },
        ],
        "*",
        100,
      ],
    },
  ],
};
```

  </Tab>
</Tabs>
